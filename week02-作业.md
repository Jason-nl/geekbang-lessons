## 作业题：JVM 虚拟机论述题
### 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）
堆是一种在JVM启动的时候创建并为对象、数组、运行时常量分配内存的一块内存区域，是JVM垃圾回收的主要内存区域
基于弱分代假说和强分代假说，划分出了新生代和老年代、
在JDK1.8之前都是物理划分、在JDK1.8之后取消了物理划分、堆内存划分成了若干个Region区域
这些Region区域包含了逻辑上的新生代和老年代

虚拟机栈是线程私有的，它与线程的生命周期同步；虚拟机栈描述的是Java方法执行的内存模型，每个方法都会创建一个栈帧，栈帧包含局部变量表，操作数栈、动态连接、方法出口等信息。

本地方法栈就是Native Stack，与Java虚拟机栈所发挥的作用是非常相似的，区别就是虚拟机栈是虚拟机执行Java方法（字节码服务），而本地方法栈则是为虚拟机使用到的Native方法服务。Native方法是通过Java通过JNI直接调用本地C/C++库，可以认为Native方法相当于C/C++暴露给Java的一个接口，Java通过调用这个接口从而调用到C/C++方法。

方法区是各个线程共享的区域，在JVM启动的时候创建，并且它的实际物理内存空间是不连续的；
方法区存储每个类的结构信息、如运行时常量池、成员变量、方法等信息
在JDK1.7及以前习惯将方法区称为永久代、从JDK1.8开始使用元空间取代了永久代，解决了永久代带来的一些问题

运行时常量池和class文件的常量池是一一对应的，它就是class文件的常量池来构建的；
运行时常量池中有两种类型：符号引用和静态常量、其中静态常量不需要后续解析、而符号引用需要进一步解析处理

String Pool在每个JVM中都只维护一份，所有类都共享的一块内存空间；
String Pool在JDK1.6之前是存放在方法区的，在1.8之后放到了java heap中
在设计String Pool的时候同时设计了类似HashTable的StringTable，在这个StringTable中保存了字符串的引用

直接内存是为提升IO读写效率而生的一块内存空间、也可以说是堆外内存；
直接内存在内存分配的过程中性能很差不如堆内存、而在读写操作过程中效率高于堆内存

#### 为什么堆内存要分年轻代和老年代？
堆内存存放对象实例，是JVM管理内存的最大一块，也是垃圾回收的最频繁的一块。分代是为了提高对象内存分配和垃圾回收的效率。

### 题目 02- 描述一个 Java 对象的生命周期
#### 解释一个对象的创建过程
在JVM启动后，当new指令的时候，首先它会到常量池中检查类是否被加载，如果未加载，它就会去加载这个类，
如果这个类已经加载完成的话，JVM会为它分配内存空间、初始化内存空间、
随后设置必要的一些信息如元信息、哈希、GC分代年龄、对象头信息
必要信息设置完、接着就是初始化对象
#### 解释一个对象的内存分配
对象的内存分配主要有指针碰撞和空闲列表两种、其中指针碰撞分配的内存地址是连续的、使用的垃圾收集器有Serial和ParNew收集器，而空闲列表分配的内存地址则不是连续的，使用的垃圾收集器有CMS和Mark-Sweep收集器

#### 解释一个对象的销毁过程
新对象申请内存空间，首先在Eden区、Eden区能放下就会进入Young区分配对象内存；Eden区放不下的时候就会YounGC、YoungGC完成之后，如果Eden Survivor能放下的时候，也会进入Young区分配对象内存，如果Eden Survivor放不下的时候，此时就会晋升老年代，晋升成功会到Old区分配对象内存，晋升失败，则FullGC、FullGC完成后，如果Old区还能放得下会进入Old区接着分配对象内存、如果Old区放不下就会直接OOM

#### 对象的 2 种访问方式是什么？
句柄和直接指针

#### 为什么需要内存担保？
因为新生代采用复制收集算法，假如大量对象在MinorGC后仍然存活，而Survivor空间是比较小的，这时候就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代中。老年代要进行内存空间分配担保，前提是老年代得有足够的内存空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代的剩余内存空间进行比较，来决定是否进行FullGC来让老年代腾出更多的空间。



### 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

有三种垃圾收集算法：

- 标记清除算法
- 复制算法
- 标记整理算法

有8种垃圾收集器：

串行收集器：

- Serial和SerialOld都是单线程执行的、在垃圾收集时，必须停止用户线程；Serial采用复制算法、而SerialOld采用标记整理算法

并行收集器：

- ParallelScavenge是一种吞吐量优先的收集器，垃圾收集需要停止用户线程；新生代使用并行回收器，采用复制算法、老年代使用串行收集器，采用标记-整理算法
- ParallelOld是ParallelScavenge的老年代版本，需要暂停用户线程，使用多线程和标记整理算法，在注重吞吐量，对CPU敏感的场景下，都可以优先考虑使用ParallelScavenge + ParallelOld收集器

- ParNew是Serial的多线程版，新生代并行采用ParNew，老年代串行采用SerialOld，因为存在线程交互的开销，单核CPU性能并不如Serial，所以单核CPU不建议使用

- CMS的特点是低延时，减少STW对用户的影响，并发收集，用户线程和收集线程一起执行，对CPU资源敏感；不会等堆慢了再收集，而是等到达阙值便开始收集，采用标记清除算法，会有内存碎片的产生，导致并发清除后，用户线程可用空间不足
- G1的特点是支持并行和并发，支持多代收集，不需要其他收集器配合就能独立管理整个GC堆，全局采用标记整理算法，局部采用复制算法，支持可预测的停顿，能让使用者指定GC消耗的时间
- ZGC的特点是支持并发、基于Region、支持压缩、NUMA感知、使用色彩指针和负载屏障、采用标记整理算法